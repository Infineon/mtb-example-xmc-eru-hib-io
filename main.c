/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: ERU-HIB-IO Example
*              for ModusToolbox.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2023, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"
#include "cy_retarget_io.h"
#include <stdio.h>
#include "xmc_eru.h"

/*******************************************************************************
* Macros
*******************************************************************************/

#define TICKS_PER_SECOND                    (1000)

/* Define macro to enable/disable printing of debug messages */
#define ENABLE_XMC_DEBUG_PRINT              (0)

/* Delay in ms */
#define DELAY_MS                            (500)

/* Define macro to set the loop count before printing debug messages */
#if ENABLE_XMC_DEBUG_PRINT
#define DEBUG_LOOP_COUNT_MAX                (2U)
#endif

/*******************************************************************************
* Data Structure
*******************************************************************************/

/*Structure for initializing ERUx_ETLy module*/
const XMC_ERU_ETL_CONFIG_t eru_etl_config =
{
    .input_a = ERU0_ETL1_INPUTA_SCU_HIB_SR0,
    .source = XMC_ERU_ETL_SOURCE_A,
    .status_flag_mode = XMC_ERU_ETL_STATUS_FLAG_MODE_HWCTRL,
    #if (UC_SERIES == XMC42)
    .edge_detection = XMC_ERU_ETL_EDGE_DETECTION_RISING
    #else
    .edge_detection = XMC_ERU_ETL_EDGE_DETECTION_FALLING
    #endif
};


/*******************************************************************************
* Global variables
*******************************************************************************/
/* counts 1ms timeTicks       */
volatile uint32_t msTicks;

/*******************************************************************************
* Function Name: SysTick_Handler
********************************************************************************
* Summary:
* This function is used to increment the tick count to be used
* for calculating delay in ms
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void SysTick_Handler(void)
{
    msTicks++;
}

/*******************************************************************************
* Function Name: delay
********************************************************************************
* Summary:
* This is the delay generation function based Systick(happens every 1 ms)
*
* Parameters:
*  uint32_t dlyTicks
*
* Return:
*  void
*
*******************************************************************************/
static void delay(uint32_t dlyTicks)
{
    uint32_t curTicks;

    curTicks = msTicks;
    while ((msTicks - curTicks) < dlyTicks)
    {
      __NOP();
    }
}

/*******************************************************************************
* Function Name: hib_io_getstate
********************************************************************************
* Summary:
* This function monitors and returns the status of HIB_IO_x pin
*
* Parameters:
*  none
*
* Return:
*  uint32_t
*
*******************************************************************************/
static uint32_t hib_io_getstate(void)
{
    uint32_t hib_io_status_flag = 0;

    if (XMC_ERU_ETL_GetStatusFlag(XMC_ERU0, 1) != 0)
    {
        hib_io_status_flag = 1;
    }

    return hib_io_status_flag;
}


/*******************************************************************************
* Function Name: hib_io_init
********************************************************************************
* Summary:
* This function routes the HIB_IO pin through ERU
*
* Parameters:
*  none
*
* Return:
*  none
*
*******************************************************************************/
static void hib_io_init(void)
{
    /* Enter Hibernate domain to enable the use of HIB_IO pins */
    XMC_SCU_HIB_EnableHibernateDomain();

    /* Setting HIB_IO_x pin as input pull-up/pull-down to detect falling/rising edge in ERU */ 
    #if (UC_SERIES == XMC43)
    XMC_SCU_HIB_SetPinMode(XMC_SCU_HIB_IO_1, XMC_SCU_HIB_PIN_MODE_INPUT_PULL_NONE);
    #elif(UC_SERIES == XMC42)
    XMC_SCU_HIB_SetPinMode(XMC_SCU_HIB_IO_0, XMC_SCU_HIB_PIN_MODE_INPUT_PULL_DOWN);
    #elif(UC_SERIES == XMC44) || (UC_SERIES == XMC45) || (UC_SERIES == XMC47) || (UC_SERIES == XMC48)
    XMC_SCU_HIB_SetPinMode(XMC_SCU_HIB_IO_1, XMC_SCU_HIB_PIN_MODE_INPUT_PULL_UP);
    #endif

    /* Route HIB_IO_x pin state though ERU */
    #if(UC_SERIES == XMC42)
    XMC_SCU_HIB_SetSR0Input(XMC_SCU_HIB_SR0_INPUT_HIB_IO_0);
    #else
    XMC_SCU_HIB_SetSR0Input(XMC_SCU_HIB_SR0_INPUT_HIB_IO_1);
    #endif

    while (XMC_SCU_GetMirrorStatus() != 0)
    {
        /* Wait until update of registers in HIB is done */
    }

    /* Initialize ERU */
    XMC_ERU_ETL_Init(XMC_ERU0, 1, &eru_etl_config);
}


/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* This example demonstrates how to route the state of hib-io pin through ERU,
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/

int main(void)
{
    cy_rslt_t result;

    #if ENABLE_XMC_DEBUG_PRINT
    /* Assign false to disable printing of debug messages*/
    static volatile bool debug_printf = true;
    /* Initialize the current loop count to zero */
    static uint32_t debug_loop_count = 0;
    #endif

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize retarget-io to use the debug UART port */
    cy_retarget_io_init(CYBSP_DEBUG_UART_HW);

    /* Initialize HIB_IO pin state though ERU */
    hib_io_init();

    #if ENABLE_XMC_DEBUG_PRINT
    printf("Initialization done\r\n");
    #endif

    /* Systick configuration */
    SysTick_Config(XMC_SCU_CLOCK_GetCpuClockFrequency() / TICKS_PER_SECOND);

    /* Infinite loop */
    while (1)
    {
        /* Continue to toggle LED till an event is detected on HIB_IO pin. On detection, the LED blinking halts */
        if ((hib_io_getstate() & 0x1) == 0)
        {
            /* Toggle LED  */
            XMC_GPIO_ToggleOutput(CYBSP_USER_LED1_PORT, CYBSP_USER_LED1_PIN);
            /* Delay 500ms  */
            delay(DELAY_MS);

            #if ENABLE_XMC_DEBUG_PRINT
            debug_loop_count++;
            if(debug_loop_count == DEBUG_LOOP_COUNT_MAX)
            {
                debug_printf = false;
                /* Print message after the loop has run DEBUG_LOOP_COUNT_MAX times */
                printf("LED blinked with no button press\r\n");
            }
            #endif
        }
    }
}

/* [] END OF FILE */
